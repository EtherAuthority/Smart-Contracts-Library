import { EncodingError } from './error';
export function assertFunctionCalled(chai, contract, fnName) {
    const fnSighash = contract.interface.getSighash(fnName);
    chai.assert(contract.provider.callHistory.some(call => call.address === contract.address && call.data.startsWith(fnSighash)), `Expected contract function ${fnName} to be called`, `Expected contract function ${fnName} NOT to be called`, undefined);
}
export function assertCalledWithParams(chai, contract, fnName, parameters, negated) {
    if (!negated) {
        assertFunctionCalled(chai, contract, fnName);
    }
    let funCallData;
    try {
        funCallData = contract.interface.encodeFunctionData(fnName, parameters);
    }
    catch (e) {
        const error = new EncodingError('Something went wrong - probably wrong parameters format');
        error.error = e;
        throw error;
    }
    chai.assert(contract.provider.callHistory.some(call => call.address === contract.address && call.data === funCallData), generateWrongParamsMessage(contract, fnName, parameters), `Expected contract function ${fnName} not to be called with parameters ${parameters}, but it was`, undefined);
}
function generateWrongParamsMessage(contract, fnName, parameters) {
    const fnSighash = contract.interface.getSighash(fnName);
    const functionCalls = contract.provider
        .callHistory.filter(call => call.address === contract.address && call.data.startsWith(fnSighash));
    const paramsToDisplay = functionCalls.slice(0, 3);
    const leftParamsCount = functionCalls.length - paramsToDisplay.length;
    return `Expected contract function ${fnName} to be called with parameters ${parameters} \
but it was called with parameters:
${paramsToDisplay.map(call => contract.interface.decodeFunctionData(fnName, call.data).toString()).join('\n')}` +
        (leftParamsCount > 0 ? `\n...and ${leftParamsCount} more.` : '');
}
//# sourceMappingURL=assertions.js.map