"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Executor_requestCoordinator;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Executor = void 0;
const has_own_1 = require("./has-own");
class Executor {
    /**
     * The Executor handles execution of methods on the given API
     */
    constructor(requestCoordinator) {
        _Executor_requestCoordinator.set(this, void 0);
        __classPrivateFieldSet(this, _Executor_requestCoordinator, requestCoordinator, "f");
    }
    /**
     * Executes the method with the given methodName on the API
     * @param methodName - The name of the JSON-RPC method to execute.
     * @param params - The params to pass to the JSON-RPC method.
     */
    execute(api, methodName, params) {
        // The methodName is user-entered data and can be all sorts of weird hackery
        // Make sure we only accept what we expect to avoid headache and heartache
        if (typeof methodName === "string") {
            // Only allow executing our *own* methods. We allow:
            //  * functions added to the Instance by the class, e.g.,
            //      class SomeClass {
            //        method = () => {} // api.hasOwnProperty("method") === true
            //      }
            //  * Or by the class' prototype:
            //      class SomeClass {
            //        method(){} // api.__proto__.hasOwnProperty("method") === true
            //      }
            if (((0, has_own_1.hasOwn)(api.__proto__, methodName) && methodName !== "constructor") ||
                (0, has_own_1.hasOwn)(api, methodName)) {
                // cast methodName from `KnownKeys<T> & string` back to KnownKeys<T> so our return type isn't weird.
                const fn = api[methodName];
                // just double check, in case a API breaks the rules and adds non-fns
                // to their API interface.
                if (typeof fn === "function") {
                    // queue up this method for actual execution:
                    return __classPrivateFieldGet(this, _Executor_requestCoordinator, "f").queue(fn, api, params);
                }
            }
        }
        throw new Error(`The method ${methodName} does not exist/is not available`);
    }
}
exports.Executor = Executor;
_Executor_requestCoordinator = new WeakMap();
//# sourceMappingURL=executor.js.map