"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RuntimeError = exports.RETURN_TYPES = void 0;
const errors_1 = require("./errors");
const utils_1 = require("@ganache/utils");
const coded_error_1 = require("./coded-error");
const utils_2 = require("@ganache/utils");
var RETURN_TYPES;
(function (RETURN_TYPES) {
    RETURN_TYPES[RETURN_TYPES["TRANSACTION_HASH"] = 0] = "TRANSACTION_HASH";
    RETURN_TYPES[RETURN_TYPES["RETURN_VALUE"] = 1] = "RETURN_VALUE";
})(RETURN_TYPES = exports.RETURN_TYPES || (exports.RETURN_TYPES = {}));
class RuntimeError extends coded_error_1.CodedError {
    constructor(transactionHash, result, returnType) {
        const execResult = result.execResult;
        const error = execResult.exceptionError.error;
        let message = errors_1.VM_EXCEPTION + error;
        super(message, utils_2.JsonRpcErrorCode.INVALID_INPUT);
        coded_error_1.CodedError.captureStackTraceExtended.bind(this, message);
        this.name = this.constructor.name;
        const hash = transactionHash.toString();
        const { returnValue } = execResult;
        const reason = coded_error_1.CodedError.createRevertReason(returnValue);
        this.message = reason ? message + " " + reason : message;
        this.data = {
            hash: hash,
            programCounter: execResult.runState.programCounter,
            result: returnType === RETURN_TYPES.TRANSACTION_HASH
                ? hash
                : utils_1.Data.from(returnValue || "0x").toString(),
            reason: reason,
            message: error
        };
    }
}
exports.RuntimeError = RuntimeError;
//# sourceMappingURL=runtime-error.js.map