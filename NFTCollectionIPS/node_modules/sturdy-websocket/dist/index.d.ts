export interface Options {
    allClearResetTime?: number;
    connectTimeout?: number;
    debug?: boolean;
    minReconnectDelay?: number;
    maxReconnectDelay?: number;
    maxReconnectAttempts?: number;
    reconnectBackoffFactor?: number;
    wsConstructor?: new (url: string, protocols?: string | string[]) => any;
    shouldReconnect?(closeEvent: CloseEvent): boolean | Promise<boolean>;
}
interface SturdyWebSocketEventMap extends WebSocketEventMap {
    down: CloseEvent;
    reopen: Event;
}
export default class SturdyWebSocket implements WebSocket {
    readonly url: string;
    static readonly DEFAULT_OPTIONS: Required<Options>;
    static readonly CONNECTING = 0;
    static readonly OPEN = 1;
    static readonly CLOSING = 2;
    static readonly CLOSED = 3;
    onclose: ((event: CloseEvent) => void) | null;
    onerror: ((event: Event) => void) | null;
    onmessage: ((event: MessageEvent) => void) | null;
    onopen: ((event: Event) => void) | null;
    ondown: ((event: CloseEvent | undefined) => void) | null;
    onreopen: ((event: Event) => void) | null;
    readonly CONNECTING = 0;
    readonly OPEN = 1;
    readonly CLOSING = 2;
    readonly CLOSED = 3;
    private readonly protocols?;
    private readonly options;
    private ws?;
    private hasBeenOpened;
    private isClosed;
    private messageBuffer;
    private nextRetryTime;
    private reconnectCount;
    private allClearTimeoutId?;
    private connectTimeoutId?;
    private binaryTypeInternal?;
    private lastKnownExtensions;
    private lastKnownProtocol;
    private readonly listeners;
    constructor(url: string, options?: Options);
    constructor(url: string, protocols: string | string[] | undefined, options?: Options);
    binaryType: BinaryType;
    readonly bufferedAmount: number;
    readonly extensions: string;
    readonly protocol: string;
    readonly readyState: number;
    close(code?: number, reason?: string): void;
    send(data: any): void;
    reconnect(): void;
    addEventListener<K extends keyof SturdyWebSocketEventMap>(type: K, listener: (this: WebSocket, event: SturdyWebSocketEventMap[K]) => void): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject): void;
    dispatchEvent(event: Event): boolean;
    removeEventListener<K extends keyof SturdyWebSocketEventMap>(type: K, listener: (this: WebSocket, event: SturdyWebSocketEventMap[K]) => void): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject): void;
    private openNewWebSocket;
    private handleOpen;
    private handleMessage;
    private handleClose;
    private handleError;
    private handleWillReconnect;
    private reestablishConnection;
    private stopReconnecting;
    private shutdown;
    private disposeSocket;
    private clearAllTimeouts;
    private clearConnectTimeout;
    private clearAllClearTimeout;
    private dispatchEventOfType;
    private callListener;
    private debugLog;
    private getTooManyFailedReconnectsMessage;
}
export {};
