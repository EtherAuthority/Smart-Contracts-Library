{"version":3,"file":"webSocketProvider.js","sourceRoot":"","sources":["../../../src/web3-adapter/webSocketProvider.ts"],"names":[],"mappings":"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","sourcesContent":["import EventEmitter from \"eventemitter3\";\nimport SturdyWebSocket from \"sturdy-websocket\";\nimport {\n  Backfiller,\n  dedupeLogs,\n  dedupeNewHeads,\n  LogsEvent,\n  LogsSubscriptionFilter,\n  makeBackfiller,\n  NewHeadsEvent,\n} from \"../subscriptions/subscriptionBackfill\";\nimport {\n  isSubscriptionEvent,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  SingleOrBatchRequest,\n  SingleOrBatchResponse,\n  SubscriptionEvent,\n  WebSocketMessage,\n} from \"../types\";\nimport { fromHex } from \"../util/hex\";\nimport { JsonRpcSenders, makeResponse } from \"../util/jsonRpc\";\nimport {\n  callWhenDone,\n  makeCancelToken,\n  throwIfCancelled,\n  withBackoffRetries,\n  withTimeout,\n} from \"../util/promises\";\nimport { SendJsonRpcPayloadFunction } from \"./sendJsonRpcPayload\";\n\nconst HEARTBEAT_INTERVAL = 30000;\nconst HEARTBEAT_WAIT_TIME = 10000;\nconst BACKFILL_TIMEOUT = 60000;\nconst BACKFILL_RETRIES = 5;\n/**\n * Subscriptions have a memory of recent events they have sent so that in the\n * event that they disconnect and need to backfill, they can detect re-orgs.\n * Keep a buffer that goes back at least these many blocks, the maximum amount\n * at which we might conceivably see a re-org.\n *\n * Note that while our buffer goes back this many blocks, it may contain more\n * than this many elements, since in the case of logs subscriptions more than\n * one event may be emitted for a block.\n */\nconst RETAINED_EVENT_BLOCK_COUNT = 10;\n\n/**\n * This is the undocumented interface required by Web3 for providers which\n * handle subscriptions.\n *\n * In addition to the stated methods here, it communicates subscription events\n * by using `EventEmitter#emit(\"data\", event)` to emit the events.\n */\nexport interface Web3SubscriptionProvider extends EventEmitter {\n  send(\n    payload: SingleOrBatchRequest,\n    callback: (error: any, response?: SingleOrBatchResponse) => void,\n  ): void;\n  disconnect(code?: number, reason?: string): void;\n  supportsSubscriptions(): true;\n  connect(): void;\n  reset(): void;\n  reconnect(): void;\n}\n\ninterface VirtualSubscription {\n  virtualId: string;\n  physicalId: string;\n  method: string;\n  params: any[];\n  isBackfilling: boolean;\n  startingBlockNumber: number;\n  sentEvents: any[];\n  backfillBuffer: any[];\n}\n\ninterface NewHeadsSubscription extends VirtualSubscription {\n  method: \"eth_subscribe\";\n  params: [\"newHeads\"];\n  isBackfilling: boolean;\n  sentEvents: NewHeadsEvent[];\n  backfillBuffer: NewHeadsEvent[];\n}\n\ninterface LogsSubscription extends VirtualSubscription {\n  method: \"eth_subscribe\";\n  params: [\"logs\", LogsSubscriptionFilter?];\n  isBackfilling: boolean;\n  sentEvents: LogsEvent[];\n  backfillBuffer: LogsEvent[];\n}\n\nexport class AlchemyWebSocketProvider\n  extends EventEmitter\n  implements Web3SubscriptionProvider\n{\n  // In the case of a WebSocket reconnection, all subscriptions are lost and we\n  // create new ones to replace them, but we want to create the illusion that\n  // the original subscriptions persist. Thus, maintain a mapping from the\n  // \"virtual\" subscription ids which are visible to the consumer to the\n  // \"physical\" subscription ids of the actual connections. This terminology is\n  // borrowed from virtual and physical memory, which has a similar mapping.\n  private readonly virtualSubscriptionsById: Map<string, VirtualSubscription> =\n    new Map();\n  private readonly virtualIdsByPhysicalId: Map<string, string> = new Map();\n  private readonly backfiller: Backfiller;\n  private heartbeatIntervalId?: NodeJS.Timeout;\n  private cancelBackfill = noop;\n\n  constructor(\n    private readonly ws: SturdyWebSocket,\n    private readonly sendJsonRpcPayload: SendJsonRpcPayloadFunction,\n    private readonly jsonRpcSenders: JsonRpcSenders,\n  ) {\n    super();\n    this.backfiller = makeBackfiller(jsonRpcSenders);\n    this.addSocketListeners();\n    this.startHeartbeat();\n  }\n\n  public send(\n    request: SingleOrBatchRequest,\n    callback: (error: any, response?: SingleOrBatchResponse) => void,\n  ): void {\n    if (isSubscribeRequest(request)) {\n      const { id } = request;\n      if (id === undefined) {\n        // The JSON-RPC spec says to return nothing if there is no request id.\n        return;\n      }\n      callWhenDone(this.subscribe(request), callback);\n      return;\n    }\n    if (isUnsubscribeRequest(request)) {\n      callWhenDone(this.unsubscribe(request), callback);\n      return;\n    }\n    callWhenDone(this.sendJsonRpcPayload(request), callback);\n  }\n\n  public supportsSubscriptions(): true {\n    return true;\n  }\n\n  public disconnect(code?: number, reason?: string): void {\n    this.removeSocketListeners();\n    this.removeAllListeners();\n    this.stopHeartbeatAndBackfill();\n    this.ws.close(code, reason);\n  }\n\n  public connect(): void {\n    // No-op. We're already connected when passed a websocket in the\n    // constructor.\n  }\n\n  public reset(): void {\n    // No-op.\n  }\n\n  public reconnect(): void {\n    // No-op. This isn't called anywhere.\n  }\n\n  private async subscribe(request: JsonRpcRequest): Promise<JsonRpcResponse> {\n    const { method, params = [] } = request;\n    const startingBlockNumber = await this.getBlockNumber();\n    const response = await this.sendJsonRpcPayload(request);\n    const id = response.result;\n    this.virtualSubscriptionsById.set(id, {\n      method,\n      params,\n      startingBlockNumber,\n      virtualId: id,\n      physicalId: id,\n      sentEvents: [],\n      isBackfilling: false,\n      backfillBuffer: [],\n    });\n    this.virtualIdsByPhysicalId.set(id, id);\n    return makeResponse(request.id!, id);\n  }\n\n  private async unsubscribe(request: JsonRpcRequest): Promise<JsonRpcResponse> {\n    const subscriptionId = request.params?.[0];\n    const virtualSubscription =\n      this.virtualSubscriptionsById.get(subscriptionId);\n    if (!virtualSubscription) {\n      return makeResponse(request.id!, false);\n    }\n    const { physicalId } = virtualSubscription;\n    const physicalRequest = { ...request, params: [physicalId] };\n    await this.sendJsonRpcPayload(physicalRequest);\n    this.virtualSubscriptionsById.delete(subscriptionId);\n    this.virtualIdsByPhysicalId.delete(physicalId);\n    return makeResponse(request.id!, true);\n  }\n\n  private addSocketListeners(): void {\n    this.ws.addEventListener(\"message\", this.handleMessage);\n    this.ws.addEventListener(\"reopen\", this.handleReopen);\n    this.ws.addEventListener(\"down\", this.stopHeartbeatAndBackfill);\n  }\n\n  private removeSocketListeners(): void {\n    this.ws.removeEventListener(\"message\", this.handleMessage);\n    this.ws.removeEventListener(\"reopen\", this.handleReopen);\n    this.ws.removeEventListener(\"down\", this.stopHeartbeatAndBackfill);\n  }\n\n  private startHeartbeat = (): void => {\n    if (this.heartbeatIntervalId != null) {\n      return;\n    }\n    this.heartbeatIntervalId = setInterval(async () => {\n      try {\n        await withTimeout(\n          this.jsonRpcSenders.send(\"net_version\"),\n          HEARTBEAT_WAIT_TIME,\n        );\n      } catch {\n        this.ws.reconnect();\n      }\n    }, HEARTBEAT_INTERVAL);\n  };\n\n  private stopHeartbeatAndBackfill = (): void => {\n    if (this.heartbeatIntervalId != null) {\n      clearInterval(this.heartbeatIntervalId);\n      this.heartbeatIntervalId = undefined;\n    }\n    this.cancelBackfill();\n  };\n\n  private handleMessage = (event: MessageEvent): void => {\n    const message: WebSocketMessage = JSON.parse(event.data);\n    if (!isSubscriptionEvent(message)) {\n      return;\n    }\n    const physicalId = message.params.subscription;\n    const virtualId = this.virtualIdsByPhysicalId.get(physicalId);\n    if (!virtualId) {\n      return;\n    }\n    const subscription = this.virtualSubscriptionsById.get(virtualId)!;\n    if (subscription.method !== \"eth_subscribe\") {\n      this.emitGenericEvent(virtualId, message.params.result);\n      return;\n    }\n    switch (subscription.params[0]) {\n      case \"newHeads\": {\n        const newHeadsSubscription = subscription as NewHeadsSubscription;\n        const newHeadsMessage = message as SubscriptionEvent<NewHeadsEvent>;\n        const { isBackfilling, backfillBuffer } = newHeadsSubscription;\n        const { result } = newHeadsMessage.params;\n        if (isBackfilling) {\n          addToNewHeadsEventsBuffer(backfillBuffer, result);\n        } else {\n          this.emitNewHeadsEvent(virtualId, result);\n        }\n        break;\n      }\n      case \"logs\": {\n        const logsSubscription = subscription as LogsSubscription;\n        const logsMessage = message as SubscriptionEvent<LogsEvent>;\n        const { isBackfilling, backfillBuffer } = logsSubscription;\n        const { result } = logsMessage.params;\n        if (isBackfilling) {\n          addToLogsEventsBuffer(backfillBuffer, result);\n        } else {\n          this.emitLogsEvent(virtualId, result);\n        }\n        break;\n      }\n      default:\n        this.emitGenericEvent(virtualId, message.params.result);\n    }\n  };\n\n  private handleReopen = (): void => {\n    this.virtualIdsByPhysicalId.clear();\n    const { cancel, isCancelled } = makeCancelToken();\n    this.cancelBackfill = cancel;\n    for (const subscription of this.virtualSubscriptionsById.values()) {\n      (async () => {\n        try {\n          await this.resubscribeAndBackfill(isCancelled, subscription);\n        } catch (error) {\n          if (!isCancelled()) {\n            console.error(\n              `Error while backfilling \"${subscription.params[0]}\" subscription. Some events may be missing.`,\n              error,\n            );\n          }\n        }\n      })();\n    }\n    this.startHeartbeat();\n  };\n\n  private async resubscribeAndBackfill(\n    isCancelled: () => boolean,\n    subscription: VirtualSubscription,\n  ): Promise<void> {\n    const {\n      virtualId,\n      method,\n      params,\n      sentEvents,\n      backfillBuffer,\n      startingBlockNumber,\n    } = subscription;\n    subscription.isBackfilling = true;\n    backfillBuffer.length = 0;\n    try {\n      const physicalId = await this.jsonRpcSenders.send(method, params);\n      throwIfCancelled(isCancelled);\n      subscription.physicalId = physicalId;\n      this.virtualIdsByPhysicalId.set(physicalId, virtualId);\n      switch (params[0]) {\n        case \"newHeads\": {\n          const backfillEvents = await withBackoffRetries(\n            () =>\n              withTimeout(\n                this.backfiller.getNewHeadsBackfill(\n                  isCancelled,\n                  sentEvents,\n                  startingBlockNumber,\n                ),\n                BACKFILL_TIMEOUT,\n              ),\n            BACKFILL_RETRIES,\n            () => !isCancelled(),\n          );\n          throwIfCancelled(isCancelled);\n          const events = dedupeNewHeads([...backfillEvents, ...backfillBuffer]);\n          events.forEach((event) => this.emitNewHeadsEvent(virtualId, event));\n          break;\n        }\n        case \"logs\": {\n          const filter: LogsSubscriptionFilter = params[1] || {};\n          const backfillEvents = await withBackoffRetries(\n            () =>\n              withTimeout(\n                this.backfiller.getLogsBackfill(\n                  isCancelled,\n                  filter,\n                  sentEvents,\n                  startingBlockNumber,\n                ),\n                BACKFILL_TIMEOUT,\n              ),\n            BACKFILL_RETRIES,\n            () => !isCancelled(),\n          );\n          throwIfCancelled(isCancelled);\n          const events = dedupeLogs([...backfillEvents, ...backfillBuffer]);\n          events.forEach((event) => this.emitLogsEvent(virtualId, event));\n          break;\n        }\n        default:\n          break;\n      }\n    } finally {\n      subscription.isBackfilling = false;\n      backfillBuffer.length = 0;\n    }\n  }\n\n  private async getBlockNumber(): Promise<number> {\n    const blockNumberHex: string = await this.jsonRpcSenders.send(\n      \"eth_blockNumber\",\n    );\n    return fromHex(blockNumberHex);\n  }\n\n  private emitNewHeadsEvent(virtualId: string, result: NewHeadsEvent): void {\n    this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n  }\n\n  private emitLogsEvent(virtualId: string, result: LogsEvent): void {\n    this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n  }\n\n  /**\n   * Emits an event to consumers, but also remembers it in its subscriptions's\n   * `sentEvents` buffer so that we can detect re-orgs if the connection drops\n   * and needs to be reconnected.\n   */\n  private emitAndRememberEvent<T>(\n    virtualId: string,\n    result: T,\n    getBlockNumber: (result: T) => number,\n  ): void {\n    const subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    // Web3 modifies these event objects once we pass them on (changing hex\n    // numbers to numbers). We want the original event, so make a defensive\n    // copy.\n    addToPastEventsBuffer(\n      subscription.sentEvents,\n      { ...result },\n      getBlockNumber,\n    );\n    this.emitGenericEvent(virtualId, result);\n  }\n\n  private emitGenericEvent(virtualId: string, result: any): void {\n    const event: SubscriptionEvent = {\n      jsonrpc: \"2.0\",\n      method: \"eth_subscription\",\n      params: {\n        subscription: virtualId,\n        result,\n      },\n    };\n    this.emit(\"data\", event);\n  }\n}\n\nfunction addToNewHeadsEventsBuffer(\n  pastEvents: NewHeadsEvent[],\n  event: NewHeadsEvent,\n): void {\n  addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\n}\n\nfunction addToLogsEventsBuffer(\n  pastEvents: LogsEvent[],\n  event: LogsEvent,\n): void {\n  addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\n}\n\n/**\n * Adds a new event to an array of events, evicting any events which\n * are so old that they will no longer feasibly be part of a reorg.\n */\nfunction addToPastEventsBuffer<T>(\n  pastEvents: T[],\n  event: T,\n  getBlockNumber: (event: T) => number,\n): void {\n  const currentBlockNumber = getBlockNumber(event);\n  // Find first index of an event recent enough to retain, then drop everything\n  // at a lower index.\n  const firstGoodIndex = pastEvents.findIndex(\n    (e) => getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT,\n  );\n  if (firstGoodIndex === -1) {\n    pastEvents.length = 0;\n  } else {\n    pastEvents.splice(0, firstGoodIndex);\n  }\n  pastEvents.push(event);\n}\n\nfunction isSubscribeRequest(\n  request: SingleOrBatchRequest,\n): request is JsonRpcRequest {\n  return !Array.isArray(request) && request.method === \"eth_subscribe\";\n}\n\nfunction isUnsubscribeRequest(\n  request: SingleOrBatchRequest,\n): request is JsonRpcRequest {\n  return !Array.isArray(request) && request.method === \"eth_unsubscribe\";\n}\n\nfunction getNewHeadsBlockNumber(event: NewHeadsEvent): number {\n  return fromHex(event.number);\n}\n\nfunction getLogsBlockNumber(event: LogsEvent): number {\n  return fromHex(event.blockNumber);\n}\n\nfunction noop(): void {\n  // Nothing.\n}\n"]}