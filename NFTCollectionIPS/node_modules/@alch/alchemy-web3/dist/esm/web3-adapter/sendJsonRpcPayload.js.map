{"version":3,"file":"sendJsonRpcPayload.js","sourceRoot":"","sources":["../../../src/web3-adapter/sendJsonRpcPayload.ts"],"names":[],"mappings":"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","sourcesContent":["import assertNever from \"assert-never\";\nimport {\n  FullConfig,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  JsonRpcSenderMiddleware,\n  Provider,\n  SingleOrBatchRequest,\n  SingleOrBatchResponse,\n} from \"../types\";\nimport { delay, promisify } from \"../util/promises\";\nimport { AlchemySendJsonRpcFunction } from \"./alchemySend\";\n\nconst ALCHEMY_DISALLOWED_METHODS: string[] = [\n  \"eth_accounts\",\n  \"eth_sendTransaction\",\n  \"eth_sign\",\n  \"eth_signTypedData_v3\",\n  \"eth_signTypedData\",\n];\n\nconst ALCHEMY_DISALLOWED_PREFIXES: string[] = [\"personal\"];\n\nexport interface JsonRpcPayloadSender {\n  sendJsonRpcPayload: SendJsonRpcPayloadFunction;\n  setWriteProvider(writeProvider: Provider | null | undefined): void;\n}\n\nexport interface SendJsonRpcPayloadFunction {\n  (payload: JsonRpcRequest): Promise<JsonRpcResponse>;\n  (payload: SingleOrBatchRequest): Promise<SingleOrBatchResponse>;\n}\n\nexport function makeJsonRpcPayloadSender(\n  alchemySendJsonRpc: AlchemySendJsonRpcFunction,\n  config: FullConfig,\n): JsonRpcPayloadSender {\n  // Copy middlewares from config.\n  const middlewares: JsonRpcSenderMiddleware[] = [];\n  config.jsonRpcSenderMiddlewares.forEach((m) => middlewares.push(m));\n\n  let currentWriteProvider = config.writeProvider;\n  middlewares.push((payload) => {\n    const disallowedMethod = getDisallowedMethod(payload);\n    if (!disallowedMethod) {\n      try {\n        return sendJsonRpcWithRetries(payload, alchemySendJsonRpc, config);\n      } catch (alchemyError) {\n        // Fallback to write provider, but if both fail throw the error from\n        // Alchemy.\n        if (!currentWriteProvider) {\n          throw alchemyError;\n        }\n        try {\n          return sendJsonRpcWithProvider(currentWriteProvider, payload);\n        } catch {\n          throw alchemyError;\n        }\n      }\n    } else {\n      if (!currentWriteProvider) {\n        throw new Error(\n          `No provider available for method \"${disallowedMethod}\"`,\n        );\n      }\n      return sendJsonRpcWithProvider(currentWriteProvider, payload);\n    }\n  });\n\n  const sendJsonRpcPayload = (\n    payload: SingleOrBatchRequest,\n  ): Promise<SingleOrBatchResponse> => {\n    const getNext = (i: number) => {\n      const middleware = middlewares[i];\n      return () => middleware(payload, getNext(i + 1));\n    };\n    return getNext(0)();\n  };\n\n  function setWriteProvider(writeProvider: Provider | null | undefined) {\n    currentWriteProvider = writeProvider ?? null;\n  }\n\n  return {\n    sendJsonRpcPayload: sendJsonRpcPayload as SendJsonRpcPayloadFunction,\n    setWriteProvider,\n  };\n}\n\nfunction sendJsonRpcWithProvider(\n  provider: Provider,\n  payload: SingleOrBatchRequest,\n): Promise<SingleOrBatchResponse> {\n  const anyProvider: any = provider;\n  const sendMethod = (\n    anyProvider.sendAsync ? anyProvider.sendAsync : anyProvider.send\n  ).bind(anyProvider);\n  return promisify((callback) => sendMethod(payload, callback));\n}\n\nfunction getDisallowedMethod(\n  payload: SingleOrBatchRequest,\n): string | undefined {\n  const payloads = Array.isArray(payload) ? payload : [payload];\n\n  // Check if the payload method is a disallowed method or starts with a\n  // disallowed prefix.\n  const disallowedRequest =\n    payloads.find(\n      (p) =>\n        ALCHEMY_DISALLOWED_METHODS.indexOf(p.method) >= 0 ||\n        ALCHEMY_DISALLOWED_PREFIXES.some((prefix) =>\n          p.method.startsWith(prefix),\n        ),\n    ) || undefined;\n  return disallowedRequest && disallowedRequest.method;\n}\n\nasync function sendJsonRpcWithRetries(\n  payload: SingleOrBatchRequest,\n  alchemySendJsonRpc: AlchemySendJsonRpcFunction,\n  { maxRetries, retryInterval, retryJitter }: FullConfig,\n): Promise<SingleOrBatchResponse> {\n  for (let i = 0; i < maxRetries + 1; i++) {\n    const result = await alchemySendJsonRpc(payload);\n    switch (result.type) {\n      case \"jsonrpc\":\n        return result.response;\n      case \"rateLimit\":\n        break;\n      case \"networkError\": {\n        const { status, message } = result;\n        const statusString = status !== 0 ? `(${status}) ` : \"\";\n        throw new Error(`${statusString} ${message}`);\n      }\n      default:\n        return assertNever(result);\n    }\n    await delay(retryInterval + ((retryJitter * Math.random()) | 0));\n  }\n  throw new Error(`Rate limited for ${maxRetries + 1} consecutive attempts.`);\n}\n"]}