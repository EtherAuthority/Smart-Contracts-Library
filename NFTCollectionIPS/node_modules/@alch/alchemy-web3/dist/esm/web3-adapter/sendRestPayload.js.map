{"version":3,"file":"sendRestPayload.js","sourceRoot":"","sources":["../../../src/web3-adapter/sendRestPayload.ts"],"names":[],"mappings":"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","sourcesContent":["import fetchPonyfill from \"fetch-ponyfill\";\nimport URI from \"urijs\";\nimport { FullConfig } from \"../types\";\nimport { delay } from \"../util/promises\";\n\nexport interface RestPayloadSender {\n  sendRestPayload: SendRestPayloadFunction;\n}\n\nexport type SendRestPayloadFunction = (\n  path: string,\n  payload: Record<string, any>,\n) => Promise<any>;\n\nexport interface RestPayloadConfig {\n  url: string;\n  config: FullConfig;\n}\n\nexport function makeRestPayloadSender({\n  url,\n  config,\n}: RestPayloadConfig): RestPayloadSender {\n  // The rest payload sender only works for alchemy.com http endpoints.\n  let error: string | undefined;\n  if (/^wss?:\\/\\//.test(url)) {\n    error = \"Alchemy rest endpoints are not available via websockets\";\n  }\n  if (!url.includes(\"alchemy\")) {\n    error =\n      \"Alchemy specific rest endpoints are not available with a non Alchemy provider.\";\n  }\n  if (url.includes(\"alchemyapi.io\") && !url.includes(\"eth-\")) {\n    error =\n      \"Alchemy specific rest endpoints on L2 networks are not available with our legacy endpoints on alchemyapi.io. Please switch over to alchemy.com\";\n  }\n\n  // Don't use the native `URL` class for this. It doesn't work in React Native.\n  const urlObject = new URI(url);\n  const origin = urlObject.origin();\n  const pathname = urlObject.path();\n  const apiKey = pathname.substring(pathname.lastIndexOf(\"/\") + 1);\n\n  const { fetch } = fetchPonyfill();\n\n  // NFT endpoints are prefixed differently, so the path must be constructed separately\n  const NFT_ENDPOINTS = [\"getNFTs\", \"getNFTMetadata\"];\n  const NFT_PREFIX = \"nft/v2/\";\n  const isNftPath = (path: string): boolean => {\n    return NFT_ENDPOINTS.includes(path);\n  };\n  const formatNftPath = (path: string): string => {\n    return NFT_PREFIX + apiKey + \"/\" + path;\n  };\n\n  const sendRestPayload = async (\n    path: string,\n    payload: Record<string, any>,\n  ): Promise<any> => {\n    if (error) {\n      throw new Error(error);\n    }\n    const { maxRetries, retryInterval, retryJitter } = config;\n    if (origin && apiKey) {\n      const endpoint = new URI(origin)\n        .search(payload)\n        .path(isNftPath(path) ? formatNftPath(path) : apiKey + path)\n        .toString();\n      for (let i = 0; i < maxRetries + 1; i++) {\n        const response = await fetch(endpoint);\n        const { status } = response;\n        switch (status) {\n          case 200:\n            return response.json();\n          case 429:\n            break;\n          default:\n            throw new Error(response.status + \":\" + response.statusText);\n        }\n        await delay(retryInterval + ((retryJitter * Math.random()) | 0));\n      }\n      throw new Error(\n        `Rate limited for ${maxRetries + 1} consecutive attempts.`,\n      );\n    }\n    return Promise.resolve();\n  };\n\n  return {\n    sendRestPayload,\n  };\n}\n"]}