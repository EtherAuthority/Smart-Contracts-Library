{"version":3,"file":"alchemySendWebSocket.js","sourceRoot":"","sources":["../../../src/web3-adapter/alchemySendWebSocket.ts"],"names":[],"mappings":"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","sourcesContent":["import SturdyWebSocket from \"sturdy-websocket\";\nimport {\n  isResponse,\n  JsonRpcId,\n  JsonRpcRequest,\n  SingleOrBatchRequest,\n  SingleOrBatchResponse,\n  WebSocketMessage,\n} from \"../types\";\nimport {\n  AlchemySendJsonRpcFunction,\n  AlchemySendJsonRpcResult,\n} from \"./alchemySend\";\n\ninterface RequestContext {\n  request: SingleOrBatchRequest;\n  resolve(response: AlchemySendJsonRpcResult): void;\n}\n\nexport function makeWebSocketSender(\n  ws: SturdyWebSocket,\n): AlchemySendJsonRpcFunction {\n  const contextsById = new Map<JsonRpcId, RequestContext>();\n  ws.addEventListener(\"message\", (message) => {\n    const response: WebSocketMessage = JSON.parse(message.data);\n    if (!isResponse(response)) {\n      return;\n    }\n    const id = getIdFromResponse(response);\n    if (id === undefined) {\n      return;\n    }\n    const context = contextsById.get(id);\n    if (!context) {\n      return;\n    }\n    const { resolve } = context;\n    contextsById.delete(id);\n    if (\n      !Array.isArray(response) &&\n      response.error &&\n      response.error.code === 429\n    ) {\n      resolve({ type: \"rateLimit\" });\n    } else {\n      resolve({ response, type: \"jsonrpc\" });\n    }\n  });\n  ws.addEventListener(\"down\", () => {\n    [...contextsById].forEach(([id, { request, resolve }]) => {\n      if (isWrite(request)) {\n        // Writes cannot be resent because they will fail for a duplicate nonce.\n        contextsById.delete(id);\n        resolve({\n          type: \"networkError\",\n          status: 0,\n          message: `WebSocket closed before receiving a response for write request with id: ${id}.`,\n        });\n      }\n    });\n  });\n  ws.addEventListener(\"reopen\", () => {\n    for (const { request } of contextsById.values()) {\n      ws.send(JSON.stringify(request));\n    }\n  });\n\n  return (request) =>\n    new Promise((resolve) => {\n      const id = getIdFromRequest(request);\n      if (id !== undefined) {\n        const existingContext = contextsById.get(id);\n        if (existingContext) {\n          const message = `Another WebSocket request was made with the same id (${id}) before a response was received.`;\n          console.error(message);\n          existingContext.resolve({\n            message,\n            type: \"networkError\",\n            status: 0,\n          });\n        }\n        contextsById.set(id, { request, resolve });\n      }\n      ws.send(JSON.stringify(request));\n    });\n}\n\nfunction getIdFromRequest(\n  request: SingleOrBatchRequest,\n): JsonRpcId | undefined {\n  if (!Array.isArray(request)) {\n    return request.id;\n  }\n  return getCanonicalIdFromList(request.map((p) => p.id));\n}\n\nfunction getIdFromResponse(\n  response: SingleOrBatchResponse,\n): JsonRpcId | undefined {\n  if (!Array.isArray(response)) {\n    return response.id;\n  }\n  return getCanonicalIdFromList(response.map((p) => p.id));\n}\n\n/**\n * Since the JSON-RPC spec allows responses to be returned in a different order\n * than sent, we need a mechanism for choosing a canonical id from a list that\n * doesn't depend on the order. This chooses the \"minimum\" id by an arbitrary\n * ordering: the smallest string if possible, otherwise the smallest number,\n * otherwise null.\n */\nfunction getCanonicalIdFromList(\n  ids: Array<JsonRpcId | undefined>,\n): JsonRpcId | undefined {\n  const stringIds: string[] = ids.filter((id) => typeof id === \"string\") as any;\n  if (stringIds.length > 0) {\n    return stringIds.reduce((bestId, id) => (bestId < id ? bestId : id));\n  }\n  const numberIds: number[] = ids.filter((id) => typeof id === \"number\") as any;\n  if (numberIds.length > 0) {\n    return Math.min(...numberIds);\n  }\n  return ids.indexOf(null) >= 0 ? null : undefined;\n}\n\nfunction isWrite(request: SingleOrBatchRequest): boolean {\n  return Array.isArray(request)\n    ? request.every(isSingleWrite)\n    : isSingleWrite(request);\n}\n\nconst WRITE_METHODS = [\"eth_sendTransaction\", \"eth_sendRawTransaction\"];\n\nfunction isSingleWrite(request: JsonRpcRequest): boolean {\n  return WRITE_METHODS.includes(request.method);\n}\n"]}