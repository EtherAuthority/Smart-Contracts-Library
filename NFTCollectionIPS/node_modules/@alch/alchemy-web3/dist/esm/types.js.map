{"version":3,"file":"types.js","sourceRoot":"","sources":["../../src/types.ts"],"names":[],"mappings":"AAAA,gFAAgF;AAsChF,MAAM,UAAU,UAAU,CACxB,OAAyB;IAEzB,OAAO,CACL,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC;QACtB,CAAC,OAAO,CAAC,OAAO,KAAK,KAAK,IAAK,OAA2B,CAAC,EAAE,KAAK,SAAS,CAAC,CAC7E,CAAC;AACJ,CAAC;AAED,MAAM,UAAU,mBAAmB,CACjC,OAAyB;IAEzB,OAAO,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;AAC9B,CAAC","sourcesContent":["// The JSON-RPC types in Web3 definitions aren't quite right. Use these instead.\n\nexport type JsonRpcId = string | number | null;\n\nexport interface JsonRpcRequest {\n  jsonrpc: \"2.0\";\n  method: string;\n  params?: any[];\n  id?: JsonRpcId;\n}\n\nexport interface JsonRpcResponse<T = any> {\n  jsonrpc: \"2.0\";\n  result?: T;\n  error?: JsonRpcError;\n  id: JsonRpcId;\n}\n\nexport type SingleOrBatchRequest = JsonRpcRequest | JsonRpcRequest[];\nexport type SingleOrBatchResponse = JsonRpcResponse | JsonRpcResponse[];\n\nexport interface JsonRpcError<T = any> {\n  code: number;\n  message: string;\n  data?: T;\n}\n\nexport interface SubscriptionEvent<T = any> {\n  jsonrpc: \"2.0\";\n  method: \"eth_subscription\";\n  params: {\n    subscription: string;\n    result: T;\n  };\n}\n\nexport type WebSocketMessage = SingleOrBatchResponse | SubscriptionEvent;\n\nexport function isResponse(\n  message: WebSocketMessage,\n): message is SingleOrBatchResponse {\n  return (\n    Array.isArray(message) ||\n    (message.jsonrpc === \"2.0\" && (message as JsonRpcResponse).id !== undefined)\n  );\n}\n\nexport function isSubscriptionEvent(\n  message: WebSocketMessage,\n): message is SubscriptionEvent {\n  return !isResponse(message);\n}\n\nexport interface AlchemyWeb3Config {\n  writeProvider?: Provider | null;\n  jsonRpcSenderMiddlewares?: JsonRpcSenderMiddleware[];\n  maxRetries?: number;\n  retryInterval?: number;\n  retryJitter?: number;\n}\n\nexport type FullConfig = Required<AlchemyWeb3Config>;\n\nexport type Provider =\n  | {\n      sendAsync(payload: any, callback: any): void;\n    }\n  | {\n      send(payload: any, callback: any): void;\n    };\n\nexport interface Eip1193Provider {\n  send(method: string, params?: any[]): Promise<any>;\n}\n\nexport interface LegacyProvider {\n  sendAsync(payload: any, callback: (error: any, result: any) => void): void;\n}\n\nexport type Web3Callback<T> = (error: Error | null, result?: T) => void;\n\nexport type SendJsonRpcFunction = (\n  method: string,\n  params?: any[],\n) => Promise<any>;\n\nexport interface TransactionsOptions {\n  address?: string;\n}\n\nexport interface PendingTransactionsOptions {\n  fromAddress?: string | string[];\n  toAddress?: string | string[];\n  hashesOnly?: boolean;\n}\n\nexport interface PendingTransactionsOptionsHashesOnly {\n  fromAddress?: string | string[];\n  toAddress?: string | string[];\n  hashesOnly: true;\n}\n\nexport type JsonRpcSenderMiddleware = (\n  req: SingleOrBatchRequest,\n  next: () => Promise<SingleOrBatchResponse>,\n) => Promise<SingleOrBatchResponse>;\n"]}